name: Release Tauri App

on:
  push:
    tags:
      - 'v*' # Trigger on version tags like v1.0.0
  workflow_dispatch: # Allow manual trigger

jobs:
  release:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target universal-apple-darwin' # Universal binary (Apple Silicon + Intel)
          - platform: 'windows-latest'
            args: ''

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: npm ci

      # macOS Code Signing
      - name: Import macOS certificate
        if: matrix.platform == 'macos-latest'
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      # Windows Code Signing
      - name: Setup Windows certificate
        if: matrix.platform == 'windows-latest'
        env:
          WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: powershell
        run: |
          Write-Host "Setting up Windows code signing certificate..."

          if ($env:WINDOWS_CERT_BASE64 -ne "") {
            # Import existing certificate from secrets (using env vars to avoid shell interpretation)
            Write-Host "Importing certificate from GitHub secrets..."
            $base64 = $env:WINDOWS_CERT_BASE64 -replace "`n", "" -replace "`r", ""
            $certBytes = [System.Convert]::FromBase64String($base64)
            $certPath = Join-Path $env:TEMP "cert.pfx"
            [System.IO.File]::WriteAllBytes($certPath, $certBytes)

            $password = ConvertTo-SecureString -String $env:WINDOWS_CERT_PASSWORD -Force -AsPlainText
            Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $password

            Remove-Item $certPath
            Write-Host "Certificate imported successfully"
          } else {
            Write-Host "No Windows certificate in secrets - building unsigned"
            Write-Host "To enable code signing, run create-windows-cert.ps1 and add secrets:"
            Write-Host "  - WINDOWS_CERTIFICATE"
            Write-Host "  - WINDOWS_CERTIFICATE_PASSWORD"
          }

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Ladder Legends Uploader ${{ github.ref_name }}'
          releaseBody: 'See the assets to download this version and install.'
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}

  rename-assets:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Rename release assets
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const draftRelease = releases.data.find(r =>
              r.draft === true && r.tag_name === context.ref.replace('refs/tags/', '')
            );

            if (!draftRelease) {
              console.log('No draft release found');
              return;
            }

            console.log('Found draft release:', draftRelease.tag_name);

            const assets = draftRelease.assets;
            const renames = [
              { pattern: /_universal\.dmg$/, newName: 'LadderLegendsUploader.dmg' },
              { pattern: /\.msi$/, newName: 'LadderLegendsUploader.msi' }
            ];

            // Remove unwanted assets (source code archives)
            const unwantedPatterns = [
              /\.zip$/,  // Source code zip
              /\.tar\.gz$/  // Source code tarball
            ];

            for (const asset of assets) {
              // Check if this is an unwanted asset
              const isUnwanted = unwantedPatterns.some(pattern => pattern.test(asset.name));
              if (isUnwanted) {
                console.log(`Deleting unwanted asset: ${asset.name}`);
                await github.rest.repos.deleteReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: asset.id
                });
                continue;
              }

              // Check if this asset needs to be renamed
              for (const rename of renames) {
                if (rename.pattern.test(asset.name)) {
                  console.log(`Renaming ${asset.name} to ${rename.newName}`);

                  // Download asset
                  const assetData = await github.rest.repos.getReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: asset.id,
                    headers: { accept: 'application/octet-stream' }
                  });

                  // Delete old asset
                  await github.rest.repos.deleteReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: asset.id
                  });

                  // Upload with new name
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: draftRelease.id,
                    name: rename.newName,
                    data: assetData.data
                  });

                  console.log(`Successfully renamed to ${rename.newName}`);
                  break;
                }
              }
            }

  publish-release:
    needs: rename-assets
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const draftRelease = releases.data.find(r =>
              r.draft === true && r.tag_name === context.ref.replace('refs/tags/', '')
            );

            if (draftRelease) {
              // Publish the new release
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: draftRelease.id,
                draft: false
              });
              console.log('Published release:', draftRelease.tag_name);

              // Delete assets from all previous releases (keep only latest)
              const oldReleases = releases.data.filter(r =>
                r.id !== draftRelease.id && r.assets.length > 0
              );

              console.log(`Found ${oldReleases.length} previous releases with assets to clean up`);

              for (const oldRelease of oldReleases) {
                console.log(`Cleaning up assets from release: ${oldRelease.tag_name}`);

                const assetsToDelete = oldRelease.assets.filter(a =>
                  // Delete all assets including source archives, binaries, signatures, and old latest.json
                  true
                );

                for (const asset of assetsToDelete) {
                  try {
                    console.log(`  Deleting asset: ${asset.name}`);
                    await github.rest.repos.deleteReleaseAsset({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      asset_id: asset.id
                    });
                  } catch (error) {
                    console.error(`  Failed to delete ${asset.name}: ${error.message}`);
                    // Continue with other assets even if one fails
                  }
                }
              }

              console.log('Cleanup complete - only latest release has assets');

              // Generate latest.json for auto-updater
              console.log('Generating latest.json for auto-updater...');

              // Remove existing latest.json if present (in case of re-run)
              const existingLatestJson = draftRelease.assets.find(a => a.name === 'latest.json');
              if (existingLatestJson) {
                console.log('Removing existing latest.json before uploading new one');
                await github.rest.repos.deleteReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: existingLatestJson.id
                });
              }

              const latestJson = {
                version: draftRelease.tag_name,
                notes: draftRelease.body,
                pub_date: draftRelease.published_at,
                platforms: {
                  'darwin-x86_64': {
                    signature: '',
                    url: `https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${draftRelease.tag_name}/LadderLegendsUploader.dmg`
                  },
                  'darwin-aarch64': {
                    signature: '',
                    url: `https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${draftRelease.tag_name}/LadderLegendsUploader.dmg`
                  },
                  'windows-x86_64': {
                    signature: '',
                    url: `https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${draftRelease.tag_name}/LadderLegendsUploader.msi`
                  }
                }
              };

              // Find and add signatures from .sig files
              const sigAssets = draftRelease.assets.filter(a => a.name.endsWith('.sig'));
              for (const sigAsset of sigAssets) {
                const sigData = await github.rest.repos.getReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: sigAsset.id,
                  headers: { accept: 'application/octet-stream' }
                });
                const signature = Buffer.from(sigData.data).toString('utf8');

                if (sigAsset.name.includes('dmg')) {
                  latestJson.platforms['darwin-x86_64'].signature = signature;
                  latestJson.platforms['darwin-aarch64'].signature = signature;
                } else if (sigAsset.name.includes('msi')) {
                  latestJson.platforms['windows-x86_64'].signature = signature;
                }
              }

              // Upload latest.json as a release asset
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: draftRelease.id,
                name: 'latest.json',
                data: JSON.stringify(latestJson, null, 2),
                headers: {
                  'content-type': 'application/json'
                }
              });

              console.log('latest.json uploaded successfully');
            }
